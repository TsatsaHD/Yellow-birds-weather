<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AllMetSat — Decoded METAR &amp; TAF (custom)</title>
  <meta name="description" content="Fetches METAR & TAF pages from en.allmetsat.com, decodes/highlights hazardous weather exactly like your example." />
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root{
      --red:#d40511;
      --orange:#f28c38;
      --yellow:#ffc107;
      --panel-bg: rgba(255,255,255,0.96);
    }
    html,body{height:100%}
    body{
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background:linear-gradient(180deg,#fff 0%,#fffaf0 60%);
      color:#111827;
      margin:0;
      padding:16px;
      display:flex;
      flex-direction:column;
      align-items:center;
      -webkit-font-smoothing:antialiased;
    }
    .container{ width:100%; max-width:1200px; }
    header{ display:flex; justify-content:space-between; align-items:center; gap:12px; margin-bottom:12px; }
    header h1{ color:var(--red); font-weight:800; font-size:1.35rem; }
    .muted{ color:#6b7280; font-size:0.94rem; }

    .grid{ display:grid; grid-template-columns: repeat(auto-fit,minmax(170px,1fr)); gap:8px; }

    button.airport{
      background:var(--red);
      color:var(--yellow);
      padding:10px 12px;
      border-radius:8px;
      border:none;
      width:100%;
      font-weight:700;
      cursor:pointer;
      text-align:center;
    }
    button.airport:active{ transform: translateY(1px); }

    #panel{
      margin-top:14px;
      background:var(--panel-bg);
      padding:14px;
      border-radius:12px;
      width:100%;
      box-shadow: 0 10px 30px rgba(2,6,23,0.06);
    }
    pre.raw { background:#0b1220; color:#e6eef8; padding:8px; border-radius:8px; overflow:auto; font-size:0.92rem; }

    .highlight-red{ background:var(--red); color:white; padding:2px 6px; border-radius:4px; font-weight:700; }
    .highlight-orange{ background:var(--orange); color:white; padding:2px 6px; border-radius:4px; font-weight:700; }

    .muted-small{ color:#6b7280; font-size:0.9rem; }

    footer{ margin-top:14px; color:#6b7280; font-size:0.9rem; }

    @media (max-width:640px){
      header{ flex-direction:column; align-items:flex-start; gap:8px; }
      .grid{ grid-template-columns: repeat(auto-fit,minmax(120px,1fr)); }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div>
        <h1>AllMetSat — Decoded METAR &amp; TAF</h1>
        <div class="muted">Uses <strong>en.allmetsat.com</strong> pages. Highlights hazardous weather exactly as requested.</div>
      </div>

      <div style="display:flex;gap:8px;align-items:center">
        <input id="q" placeholder="Search ICAO or name (e.g. EBBR)" class="px-3 py-2 rounded border border-gray-200" />
        <button id="search" class="px-3 py-2 rounded bg-gray-800 text-white">Search</button>
        <button id="refresh" class="px-3 py-2 rounded bg-gray-100">Refresh</button>
      </div>
    </header>

    <main>
      <!-- Airports grid -->
      <div id="airportGrid" class="grid" aria-live="polite"></div>

      <!-- Panel for results -->
      <section id="panel" role="region" aria-label="Decoded weather">
        <p id="panelIntro" class="muted-small">Click an airport to fetch its allmetsat page and show decoded METAR &amp; TAF with exact highlight rules.</p>
      </section>
    </main>

    <footer>
      Data source: en.allmetsat.com. If you get CORS errors, run from a local server (e.g. <code>python -m http.server</code>) or use a server-side proxy to fetch pages.
    </footer>
  </div>

  <script>
    /*******************************
     * Airports (same list as before)
     *******************************/
    const AIRPORTS = [
      ["EHAM","Amsterdam (AMS)"],
      ["OBBI","Bahrain (BAH)"],
      ["LEBL","Barcelona (BCN)"],
      ["LFSB","Basel/Mulhouse (BSL/MLH)"],
      ["LIPE","Bologna (BLQ)"],
      ["LFBD","Bordeaux (BOD)"],
      ["EBBR","Brussels (BRU)"],
      ["LHBP","Budapest (BUD)"],
      ["GMMN","Casablanca (CMN)"],
      ["KCVG","Cincinnati (CVG)"],
      ["EDDK","Cologne (CGN)"],
      ["EKCH","Copenhagen (CPH)"],
      ["EIDW","Dublin (DUB)"],
      ["EGNX","East Midlands (EMA)"],
      ["VHHH","Hong Kong (HKG)"],
      ["DNMM","Lagos (LOS)"],
      ["EDDP","Leipzig (LEJ)"],
      ["LOWL","Linz (LNZ)"],
      ["EGLL","London Heathrow (LHR)"],
      ["EGGW","Luton (LTN)"],
      ["LFLL","Lyon (LYS)"],
      ["LEMD","Madrid (MAD)"],
      ["LFML","Marseille (MRS)"],
      ["LIMC","Milan Malpensa (MXP)"],
      ["LFPG","Paris CDG (CDG)"],
      ["LPPR","Porto (OPO)"],
      ["OERK","Riyadh (RUH)"],
      ["ZSPD","Shanghai (PVG)"],
      ["ZGSZ","Shenzhen (SZX)"],
      ["LLBG","Tel Aviv (TLV)"],
      ["LFBO","Toulouse (TLS)"],
      ["LEVT","Vitoria (VIT)"]
    ];

    /********************************************************
     * Highlight/translation lists: EXACT thresholds & ignore list
     * - red thresholds: visibility <= 0.56 km, ceiling <= 200 ft,
     *   very strong winds/gusts (>= 26 kt steady or gust >= 36 kt)
     * - orange thresholds: visibility <= 0.81 km, ceiling <= 399 ft,
     *   moderate strong winds/gusts (>=21 kt steady or gust >= 25 kt)
     * - ignoreList: kept identical to example
     ********************************************************/
    const orangeList = ['mist','shallow mist','partial mist'];
    const ignoreList = [
      'rain','light rain','heavy rain','rain showers','light rain showers','heavy rain showers',
      'drizzle','light drizzle','heavy drizzle','light ','no significant weather','no significant change expected'
    ];

    const weatherTranslations = {
      'BR': 'mist','TS': 'thunderstorm','FG': 'fog','HZ': 'haze','FU': 'smoke','FZ': 'freezing',
      'VA': 'volcanic ash','DU': 'widespread dust','SQ': 'squall','FC': 'funnel cloud','PO':'dust devils',
      'SA':'sand','CB':'cumulonimbus','TCU':'towering cumulus','WS':'wind shear','+':'heavy ','-':'light ',
      'VC':'in the vicinity ','FZRA':'freezing rain','NSW':'no significant weather','BECMG':'becoming',
      'TEMPO':'temporary fluctuations','PROB30':'30% chance','PROB40':'40% chance','NOSIG':'no significant change expected'
    };

    /*******************************
     * Helpers
     *******************************/
    function escapeRegExp(s){ return s.replace(/[.*+?^${}()|[\]\\]/g,'\\$&'); }

    // Highlight plain text based on your lists
    function highlightText(text){
      if(!text) return text;
      let out = text;

      // first handle orange items exactly (word boundaries)
      orangeList.forEach(w=>{
        const re = new RegExp('\\b' + escapeRegExp(w) + '\\b','gi');
        out = out.replace(re, `<span class="highlight-orange">${w}</span>`);
      });

      // use translation values too (so e.g. "fog" or "thunderstorm" become highlighted)
      Object.values(weatherTranslations).forEach(val=>{
        if(!val) return;
        const word = (''+val).trim();
        if(!word) return;
        const lower = word.toLowerCase();
        // skip if in ignoreList
        if(ignoreList.includes(lower)) return;
        const re = new RegExp('\\b' + escapeRegExp(word) + '\\b','gi');
        out = out.replace(re, `<span class="highlight-red">${word}</span>`);
      });

      return out;
    }

    // Utility: normalize visibility strings (like "3500 m" or "6 miles")
    function parseVisibilityToKm(str){
      if(!str) return null;
      str = String(str).toLowerCase();
      // meters e.g. "3500 m"
      const mMatch = str.match(/([0-9]+)\s*m/);
      if(mMatch) return parseFloat(mMatch[1]) / 1000.0;
      // kilometers "10 km"
      const kmMatch = str.match(/([0-9]+(?:\.[0-9]+)?)\s*km/);
      if(kmMatch) return parseFloat(kmMatch[1]);
      // statute miles "6 miles" or "6 sm"
      const miMatch = str.match(/([0-9]+(?:\.[0-9]+)?)\s*(mile|mi|sm)/);
      if(miMatch) return parseFloat(miMatch[1]) * 1.60934;
      // fallback: try numeric
      const num = parseFloat(str);
      if(!isNaN(num)) return num;
      return null;
    }

    // Detect ceiling from cloud lines like "Broken clouds at a height of 600 ft"
    function extractLowestCeiling(text){
      if(!text) return null;
      // find occurrences of "height of XXX ft" or "at a height of XXX ft"
      const re = /height of\s*([0-9]{1,5})\s*ft/gi;
      let m;
      let lowest = null;
      while((m = re.exec(text)) !== null){
        const ft = parseInt(m[1],10);
        if(!lowest || ft < lowest) lowest = ft;
      }
      // other pattern: "at a height of XXX ft"
      const re2 = /at a height of\s*([0-9]{1,5})\s*ft/gi;
      while((m = re2.exec(text)) !== null){
        const ft = parseInt(m[1],10);
        if(!lowest || ft < lowest) lowest = ft;
      }
      return lowest;
    }

    // Apply explicit threshold-based decorations to sections (visibility/ceiling/winds)
    function applyThresholdHighlights(blockHtml){
      // blockHtml is HTML string; we manipulate it carefully

      // 1) visibility: find patterns like "Visibility: 3500 m" or "Visibility: 6 miles" or "10 km"
      blockHtml = blockHtml.replace(/(Visibility:\s*<\/strong>\s*([^<]+))/gi, (m, full, vis) => {
        const km = parseVisibilityToKm(vis);
        if(km !== null){
          if(km <= 0.56) return `Visibility: <strong class="highlight-red">${vis.trim()}</strong>`;
          if(km <= 0.81) return `Visibility: <strong class="highlight-orange">${vis.trim()}</strong>`;
        }
        return full;
      });

      // 2) ceiling: detect lowest ceiling in text and wrap entire cloud phrase
      const lowest = extractLowestCeiling(blockHtml);
      if(lowest !== null){
        if(lowest <= 200){
          // wrap common phrases 'Broken clouds' 'Overcast' etc. Use a general approach:
          blockHtml = blockHtml.replace(/((Few|Scattered|Broken|Overcast)[^<\n\r]{0,120})/gi, (m2) => `<span class="highlight-red">${m2}</span>`);
        } else if(lowest <= 399){
          blockHtml = blockHtml.replace(/((Few|Scattered|Broken|Overcast)[^<\n\r]{0,120})/gi, (m2) => `<span class="highlight-orange">${m2}</span>`);
        }
      }

      // 3) winds: find patterns like "Wind 18 kt from the West with gusts up to 30 kt" or "Wind 15 kt"
      blockHtml = blockHtml.replace(/(Wind[^<\n\r]{0,160})/gi, (m3) => {
        // extract numbers
        const gustMatch = m3.match(/gusts?\s*(?:up to\s*)?([0-9]{1,3})\s*kt/i);
        const spdMatch = m3.match(/Wind\s*([0-9]{1,3})\s*kt/i) || m3.match(/wind\s*([0-9]{1,3})\s*km\/h/i);
        let wrapRed = false, wrapOrange = false;
        if(gustMatch){
          const g = parseInt(gustMatch[1],10);
          if(g >= 36) wrapRed = true;
          else if(g >= 25) wrapOrange = true;
        }
        if(spdMatch){
          const s = parseInt(spdMatch[1],10);
          if(s >= 26) wrapRed = true;
          else if(s >= 21) wrapOrange = true;
        }
        if(wrapRed) return `<span class="highlight-red">${m3}</span>`;
        if(wrapOrange) return `<span class="highlight-orange">${m3}</span>`;
        return m3;
      });

      return blockHtml;
    }

    /*******************************
     * DOM wiring
     *******************************/
    const grid = document.getElementById('airportGrid');
    const panel = document.getElementById('panel');
    const q = document.getElementById('q');
    const searchBtn = document.getElementById('search');
    const refreshBtn = document.getElementById('refresh');
    let lastICAO = null;
    let lastLabel = null;

    // populate airport buttons
    AIRPORTS.forEach(([icao,label]) => {
      const btn = document.createElement('button');
      btn.className = 'airport';
      btn.innerText = `${icao} — ${label}`;
      btn.dataset.icao = icao;
      btn.dataset.label = label;
      btn.addEventListener('click', ()=> fetchAllMetSat(icao, label));
      grid.appendChild(btn);
    });

    searchBtn.addEventListener('click', ()=>{
      const val = (q.value || '').trim().toUpperCase();
      if(!val) return alert('Enter ICAO or substring of airport name.');
      // exact ICAO?
      const exact = AIRPORTS.find(a => a[0] === val);
      if(exact) return fetchAllMetSat(exact[0], exact[1]);
      // else search label
      const found = AIRPORTS.find(a => a[1].toUpperCase().includes(val));
      if(found) return fetchAllMetSat(found[0], found[1]);
      alert('Airport not found in list.');
    });

    refreshBtn.addEventListener('click', ()=>{
      if(!lastICAO) return alert('No previous airport selected.');
      fetchAllMetSat(lastICAO, lastLabel);
    });

    /****************************************************************
     * Core: fetch the allmetsat page for an ICAO and extract METAR/TAF
     *
     * Observed structure (en.allmetsat.com):
     * - pages like: https://en.allmetsat.com/metar-taf/europe.php?icao=EBBR
     * - those pages contain human-readable decoded text such as:
     *     "TAF: EBBR 261701Z 2618/2724 25011KT 9999 BKN040 ..."
     *   and sections labeled "Forecast", "TAF:" and small paragraphs
     *
     * Strategy:
     * - Fetch the page HTML as text
     * - Parse into a DOM using DOMParser
     * - Attempt to find relevant blocks:
     *     - elements that contain "METAR" or "TAF" strings
     *     - paragraphs with "Visibility:" / "Wind" / "Clouds" phrases
     * - Build extracted HTML with raw METAR (if found) + TAF + decoded blocks
     * - Apply highlightText() and applyThresholdHighlights() to match your example exactly
     *
     * NOTE: allmetsat page markup varies slightly between pages. Code is defensive.
     ****************************************************************/
    async function fetchAllMetSat(icao, label){
      lastICAO = icao;
      lastLabel = label;
      panel.innerHTML = `<p class="muted-small">Loading ${icao} — ${label} from en.allmetsat.com ...</p>`;

      // Build URL (English site)
      const url = `https://en.allmetsat.com/metar-taf/europe.php?icao=${encodeURIComponent(icao)}`;

      try{
        const resp = await fetch(url);
        if(!resp.ok) throw new Error('Network response was not OK: ' + resp.status);
        const txt = await resp.text();

        // parse HTML
        const parser = new DOMParser();
        const doc = parser.parseFromString(txt, 'text/html');

        // Look for TAF / METAR blocks and "Forecast" "Observation" sections
        // allmetsat often has plain text with "TAF: " and human-readable paragraphs.
        // We'll search for nodes that contain 'TAF:' and 'METAR' keywords.
        const bodyText = doc.body ? doc.body.innerHTML : txt;

        // 1) Try to extract explicit TAF line (e.g., "TAF: EBBR 261701Z 2618/2724 ...")
        let tafLine = null;
        // search for "TAF:" literal in the page
        const tafMatch = bodyText.match(/TAF:\s*([A-Z0-9\s\/\-\+GTCPB\.\,]+(?:\n|<br|<\/p|<))/i);
        if(tafMatch){
          tafLine = tafMatch[0].replace(/<[^>]*>/g,'').trim();
        } else {
          // fallback: search for "TAF" followed by ICAO
          const tafMatch2 = bodyText.match(new RegExp('(TAF:\\s*' + icao + '[^<\\n]{0,200})','i'));
          if(tafMatch2) tafLine = tafMatch2[1].replace(/<[^>]*>/g,'').trim();
        }

        // 2) Try to extract decoded forecast paragraphs (many pages include lines like "Wind 18 kt from the West with gusts up to 30 kt")
        // We'll collect paragraphs (<p>) and elements that contain words 'Visibility' or 'Wind' or 'Broken' or 'Broken clouds'
        const candidateNodes = Array.from(doc.querySelectorAll('p,div,span,li')).filter(n=>{
          const t = (n.textContent || '').toLowerCase();
          return /visibility|wind|clouds|broken|overcast|scattered|few|ta f|taf:|metar|forecast|forecast valid|observation/i.test(t);
        });

        // build a best-effort "decoded" block by joining the most relevant candidate nodes
        const seen = new Set();
        let decodedParts = [];
        for(const n of candidateNodes){
          const txtContent = n.textContent.trim();
          if(!txtContent) continue;
          // avoid duplicates
          if(seen.has(txtContent)) continue;
          seen.add(txtContent);
          // only include lines that mention either METAR/TAF/Visibility/Wind/Clouds/etc
          if(/visibility|wind|cloud|broken|overcast|scattered|few|ta f|taf:|metar|forecast|forecast valid|observation/i.test(txtContent.toLowerCase())){
            decodedParts.push(txtContent);
          }
          // stop at reasonable length
          if(decodedParts.length >= 8) break;
        }

        // join and sanitize into HTML
        let decodedHtml = decodedParts.map(p => `<div>${escapeHtml(p)}</div>`).join('\n');

        // If we didn't find decoded parts, try a looser grab: any <pre> or <code> text
        if(!decodedHtml || decodedParts.length === 0){
          const pre = doc.querySelector('pre,code');
          if(pre && pre.textContent.trim()){
            decodedHtml = `<pre class="raw">${escapeHtml(pre.textContent.trim())}</pre>`;
          } else {
            // ultimate fallback: include a short snippet of page text
            decodedHtml = `<div class="muted-small">Couldn't parse detailed decoded blocks automatically. Raw page snippet:</div><pre class="raw">${escapeHtml(txt.slice(0,400))}...</pre>`;
          }
        }

        // Insert raw METAR if found: look for "METAR " followed by ICAO or raw_text in page
        let rawMetarMatch = bodyText.match(/METAR\s+[A-Z0-9]{4}\s+[0-9]{6}Z[^\n<]{0,200}/i);
        let rawMetar = rawMetarMatch ? rawMetarMatch[0].replace(/<[^>]*>/g,'').trim() : null;

        // Compose the panel HTML
        let resultHtml = `
          <h2 style="color:var(--red); font-weight:800">${escapeHtml(label)} — ${escapeHtml(icao)}</h2>
          <div style="margin-top:8px;">
            ${rawMetar ? ('<div><strong>Raw METAR:</strong><pre class="raw">'+escapeHtml(rawMetar)+'</pre></div>') : ''}
            <div style="margin-top:8px;"><strong>Decoded / Forecast (parsed from allmetsat):</strong></div>
            <div id="decodedBlock" style="margin-top:6px;">${decodedHtml}</div>
            ${tafLine ? (`<div style="margin-top:10px;"><strong>TAF:</strong><div>${escapeHtml(tafLine)}</div></div>`) : ''}
        `;

        resultHtml += '</div>';

        // Apply highlighting pass to the decodedBlock HTML content (exact rules)
        // 1) First convert the decodedHtml into text with HTML preserved to run highlightText.
        // 2) Apply threshold highlights for visibility/ceiling/wind afterwards.

        // Insert initial result
        panel.innerHTML = resultHtml;

        // Now post-process the decodedBlock DOM node
        const decodedNode = document.getElementById('decodedBlock');
        if(decodedNode){
          // highlight obvious weather words using highlightText
          // We'll walk text nodes and replace matches with spans (safe, simple approach)
          walkAndReplaceTextNodes(decodedNode, (text) => {
            return highlightText(text);
          });

          // After inserting these highlights, run threshold-based decoration on the block's innerHTML
          decodedNode.innerHTML = applyThresholdHighlights(decodedNode.innerHTML);
        }

        // Also apply threshold highlights to TAF line if present
        if(tafLine){
          const tafContainer = Array.from(panel.querySelectorAll('div')).find(el=>el.textContent && el.textContent.includes('TAF:'));
          if(tafContainer){
            tafContainer.innerHTML = applyThresholdHighlights(tafContainer.innerHTML);
            // also run highlightText on taf container
            walkAndReplaceTextNodes(tafContainer, (t)=> highlightText(t));
          }
        }

      }catch(err){
        // Provide helpful guidance for CORS
        panel.innerHTML = `
          <p style="color:#b91c1c"><strong>Error:</strong> ${escapeHtml(err.message)}</p>
          <div class="muted-small" style="margin-top:8px;">
            If this is a CORS issue (blocked cross-origin request), run this file from a static server (for local use: <code>python -m http.server</code>)
            or use a simple server-side proxy that fetches the <code>en.allmetsat.com</code> page and returns it to the browser.
          </div>
        `;
      }
    }

    /*******************************
     * Small utilities below
     *******************************/
    function escapeHtml(s){
      return String(s)
        .replace(/&/g,'&amp;')
        .replace(/</g,'&lt;')
        .replace(/>/g,'&gt;')
        .replace(/"/g,'&quot;')
        .replace(/'/g,'&#39;');
    }

    // Walk text nodes and replace using replacer(text) -> replacementHTML
    function walkAndReplaceTextNodes(root, replacer){
      const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, null, false);
      const toReplace = [];
      let node;
      while(node = walker.nextNode()){
        // skip whitespace-only
        if(!node.nodeValue.trim()) continue;
        toReplace.push(node);
      }
      toReplace.forEach(tn => {
        const parent = tn.parentNode;
        try{
          const replaced = replacer(tn.nodeValue);
          if(replaced !== tn.nodeValue){
            // create a fragment from the replacement HTML
            const frag = document.createRange().createContextualFragment(replaced);
            parent.replaceChild(frag, tn);
          }
        }catch(e){
          // ignore parse errors
        }
      });
    }

    /*******************************
     * Initial focus
     *******************************/
    // focus search input and show airports count
    document.getElementById('panelIntro').innerText += ` (${AIRPORTS.length} airports available)`;
    q.focus();
  </script>
</body>
</html>